name: Terraform Infrastructure Deployment and EKS Deployment

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Choose whether to apply, destroy, deploy infrastructure'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy
          - deploy

jobs:
  terraform:
    runs-on: ubuntu-latest
    outputs:
      no_changes: ${{ steps.check_changes.outputs.no_changes }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v2

      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.4.6

      - name: Check if Terraform Plan has changes
        id: check_changes
        run: |
          terraform init
          terraform plan -out=tfplan
          terraform show -no-color ./tfplan > plan_output.txt
          if grep -q 'No changes' plan_output.txt; then
            echo "No changes detected. Skipping apply."
            echo "no_changes=true" >> $GITHUB_ENV
            echo "::set-output name=no_changes::true"
          else
            echo "Changes detected. Proceeding with apply."
            echo "no_changes=false" >> $GITHUB_ENV
            echo "::set-output name=no_changes::false"
          fi
        working-directory: ./terraformfiles

      - name: Terraform Apply
        if: steps.check_changes.outputs.no_changes == 'false' && github.event.inputs.action == 'apply'
        run: |
          terraform apply -auto-approve ./tfplan
        working-directory: ./terraformfiles
        env:
          TF_VAR_cluster_name: ${{ secrets.TF_VAR_CLUSTER_NAME }}

      - name: Extract ECR URL from Terraform State
        if: github.event.inputs.action == 'apply'
        id: extract_ecr_url
        run: |
          # Extract the ECR URL using terraform show and jq
          ecr_url=$(terraform show -json | jq -r '.values.root_module.resources[] | select(.type=="aws_ecr_repository") | .values.repository_url')
          
          # Export the ECR URL as an environment variable
          echo "ecr_url=$ecr_url" >> $GITHUB_ENV

      - name: Update deployment.yaml with ECR URL
        if: github.event.inputs.action == 'apply'
        run: |
          echo "Updating values.yaml with new repository URL"
          sed -i 's|image:.*|image: ${REPOSITORY_URL}|g' k8s/deployment.yaml
        env:
          REPOSITORY_URL: ${{ env.ecr_url }}

      - name: Commit changes to deployment.yaml
        if: github.event.inputs.action == 'apply'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add k8s/deployment.yaml
          git commit -m "Update ECR repository URL in deployment.yaml"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}

      # Clean up any unnecessary files from the Terraform directory to avoid committing them
      - name: Clean up Terraform files
        run: |
          rm -rf .terraform
          rm -f terraform.tfstate terraform.tfstate.backup terraform.lock.hcl

  deploy:
    runs-on: ubuntu-latest
    needs: terraform
    if: github.event.inputs.action == 'deploy' || github.event.inputs.action == 'apply' || github.event.inputs.action == 'destroy'

    steps:
      - name: Check out code
        uses: actions/checkout@v2

      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      - name: Set up Docker Buildx
        if: github.event.inputs.action == 'deploy'
        uses: docker/setup-buildx-action@v2

      - name: Log in to Amazon ECR
        if: github.event.inputs.action == 'deploy'
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_DEFAULT_REGION }} |
          docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com

      - name: Build Docker image
        if: github.event.inputs.action == 'deploy'
        run: |
          VERSION="1.0.0"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          IMAGE_TAG="${VERSION}-${TIMESTAMP}"
          docker build -t ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/my-python-app:$IMAGE_TAG .
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/my-python-app:$IMAGE_TAG

      - name: Update deployment.yaml with new image tag
        if: github.event.inputs.action == 'deploy'
        run: |
          VALUES_FILE="k8s/deployment.yaml"
          echo "Updating deployment.yaml with new image tag: ${IMAGE_TAG}"
          sed -i "s|repository:.*|repository: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/my-python-app|g" $VALUES_FILE
          sed -i "s|image: \".*:\(.*\)\"|image: \"${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/my-python-app:$IMAGE_TAG\"|g" $VALUES_FILE

      - name: Commit and push changes to values.yaml
        if: github.event.inputs.action == 'deploy'
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git remote set-url origin https://x-access-token:${{ secrets.GH_PAT }}@github.com/kpavankalyan534/terraform-eks.git
          git add k8s/deployment.yaml
          git commit -m "Update Docker image tag in values.yaml to $IMAGE_TAG"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
      - name: Set up Kubeconfig for EKS
        run: |
          aws eks --region ${{ secrets.AWS_DEFAULT_REGION }} update-kubeconfig --name ${{ secrets.TF_VAR_CLUSTER_NAME }}
      - name: Deploy Application
        if: github.event.inputs.action == 'deploy'
        run: |
          kubectl apply -f k8s/deployment.yaml
        working-directory: ./

      - name: Wait for LoadBalancer to be provisioned
        if: github.event.inputs.action == 'deploy'
        run: |
          export ELB_DNS=$(kubectl get svc python-app-service -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "ELB DNS name: $ELB_DNS"
          echo "ELB_DNS=$ELB_DNS" >> $GITHUB_ENV

      - name: Clone the repository to update DNS record
        if: github.event.inputs.action == 'deploy'
        run: |
          # Use sed to update the DNS record in the dns.tf file with the new ELB DNS
          sed -i "s|records = \[.*\]|records = [\"${{ env.ELB_DNS }}\"]|g" terraformfiles/dns.tf

      - name: Apply Terraform Changes to Update CNAME Record
        if: github.event.inputs.action == 'deploy'
        run: |
          terraform init
          terraform plan -out=tfplan
          terraform apply -auto-approve
        working-directory: ./terraformfiles

      # Destroy step executed only when "destroy" action is selected
      # - name: Delete Kubernetes resources
      #   if: github.event.inputs.action == 'destroy'
      #   run: |
      #     kubectl delete -f k8s/deployment.yaml
          # Add more kubectl delete commands here if needed

      # Destroy step executed only when "destroy" action is selected
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.4.6  # Specify your desired version here

      - name: Initialize Terraform
        run: terraform init
        working-directory: ./terraformfiles
      - name: Terraform Destroy
        if: github.event.inputs.action == 'destroy'
        run: |
          terraform destroy -auto-approve
        working-directory: ./terraformfiles
        env:
          TF_VAR_cluster_name: ${{ secrets.TF_VAR_CLUSTER_NAME }}
